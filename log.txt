2017.10.03
main.cpp	==> line. 72 이후 함수 호출을, 인공지능 두개로 변경
		-  함수 정보 (변경 내용, 주석이 변경 전)
coordinator.SetParticipants({
        
	CreateParticipant(Util::GetRaceFromString(botRaceString), &bot),
		
	CreateParticipant(Util::GetRaceFromString(enemyRaceString), &enemybot)
     
	//   CreateComputer(Util::GetRaceFromString(enemyRaceString))
    
});

TechTree.cpp	==> initUnitTypeData() 함수 내
		- m_upgradeData[0] = TypeData(); 을 m_unitTypeData[0] = TypeData(); 로 수정
		==> const TypeData & TechTree::getData(const sc2::UpgradeID & type)  const 함수 내
		- return m_unitTypeData.at(0); 을 return m_upgradeData.at(0); 로 수정


**참고 : 특정 종족에 대한 전략 만들고 싶다면, UseEnemySpecificStrategy를 Strategy 안에(StManager 122 참조)

stManager.cpp line 164~
		==> 전략 반복 진행 하기 위한 부분 (아직 미작성)

2017.10.04
** 동작 원리 분석 : onStart 실행 후, onFrame이 반복 실행. (스레드 형태로 반복 콜을 하는듯)
** 반복생산은 BuildOrderQueue 에서 m_queue가 비면 다시 실행시키는 방식으로?
	--> 그 위치는 아마도 ProductionManager.cpp 의 line 50, manageBuildOrderQueue() 함수 내

** Utill.cpp의 line 218
bool Util::IsCombatUnitType(const sc2::UnitTypeID & type, CCBot & bot)
{
    
	if (IsWorkerType(type)) { return true; }
    
	if (IsSupplyProviderType(type)) { return false; }
    
	if (bot.Data(type).isBuilding) { return false; }

 
   
	if (type == sc2::UNIT_TYPEID::ZERG_EGG) { return false; }
    
	if (type == sc2::UNIT_TYPEID::ZERG_LARVA) { return false; }

  
  
	return true;

}
첫번째, 일꾼의 타입을 true로 변경했더니, 정찰해온 일꾼들을 공격함. 그렇지만 진짜 공격유닛은 공격하지 않는다.


2017.10.6
StrategyManager 헤더와 소스 수정 중.
onFrame에 반복생산 구문을 넣기 위해, 변수 재조정 필요
==> 아니엇음, ProductionManager.cpp line 50~ manageBuildOrderQueue() 함수 내에서 동작 실험 (ProductionManager의 onFrame()에서 호출되는 함수)
// if there is nothing in the queue, oh well
    if (m_queue.isEmpty())
    {
		setBuildOrder(m_bot.Strategy().getOpeningBookBuildOrder());
        return;
    }


** 대부분의 로직이 존재하는 클래스는 CCBot을 가지고 있음

// 다음 과제, 유닛이 모이기 전에 공격가는거 안하도록 혹은 일꾼의 공격성을 줄이되, 정찰온 일꾼은 방어하는 형식으로